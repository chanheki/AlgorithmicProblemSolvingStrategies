# [ê³„ì‚° ê¸°í•˜ ComputationalGeometry ]()


## ê³„ì‚° ê¸°í•˜ (computational geometry) ì•Œê³ ë¦¬ì¦˜

ì , ì„ , ë‹¤ê°í˜•ê³¼ ì› ë“± ê°ì¢… ê¸°í•˜í•™ì  ë„í˜•ì„ ë‹¤ë£¨ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ê³„ì‚° ê¸°í•˜ (computational geometry) ì•Œê³ ë¦¬ì¦˜ì´ë¼ê³  í•©ë‹ˆë‹¤.

## ê³„ì‚° ê¸°í•˜ì˜ ë„êµ¬ë“¤

### ë²¡í„°ì˜ êµ¬í˜„

ë²¡í„°ëŠ” ë°©í–¥ê³¼ ê±°ë¦¬. ë²¡í„°ë¥¼ ê·¸ë¦¼ìœ¼ë¡œ ê·¸ë¦´ ìˆ˜ ìˆëŠ” ê°€ì¥ ì§ê´€ì ì¸ ë°©ë²•ì€ í™”ì‚´í‘œ. í™”ì‚´í‘œëŠ” ë°©í–¥ê³¼ ê¸¸ì´ë¥¼ ëª¨ë‘ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆê¸° ë•Œë¬¸.
ë²¡í„°ëŠ” ë°©í–¥ê³¼ ê±°ë¦¬ì˜ ìŒì´ê¸° ë•Œë¬¸ì—, í™”ì‚´í‘œì˜ ì‹œì‘ì ì´ ì–´ë””ì¸ì§€ ì¤‘ìš”í•˜ì§€ëŠ” ì•Šë‹¤. ë²¡í„°ì˜ ì‹œì‘ì ì€ ì¢Œí‘œ ê³µê°„ì˜ ì›ì ìœ¼ë¡œ ì •í•´ë‘ë©´, í™”ì‚´í‘œì˜ ëì ì˜ ìœ„ì¹˜ë¥¼ (x, y)ë¡œë§Œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

[vector2 êµ¬ì¡°ì²´ êµ¬í˜„ ğŸ”—](ComputationalGeometry/vector2.swift)

[swift SIMD2 vector2 ê´€ë ¨ ë” ì•Œì•„ë‘ë©´ ì¢‹ì„ ê²ƒğŸ”—](ComputationalGeometry/vector_simd2.swift)

- ë²¡í„°ì˜ ë§ì…ˆ: ë‘ ë²¡í„° Aì™€ Bê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ë²¡í„°ì˜ ë§ì…ˆì€ ê° ë²¡í„°ì˜ ì‹œì‘ì ì„ ì›ì ìœ¼ë¡œ ê°„ì£¼í•˜ê³  ë‘ ë²¡í„°ì˜ ëì ì„ ì—°ê²°í•˜ëŠ” ë²¡í„° Cë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ì´ ë²¡í„° CëŠ” ì›ë˜ì˜ ë‘ ë²¡í„° Aì™€ Bì˜ í•©ìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤. ê¸°í•˜í•™ì ìœ¼ë¡œ ì´ëŠ” ë²¡í„° Aì˜ ëì ì—ì„œ ë²¡í„° Bì˜ ì‹œì‘ì ì„ ì—°ê²°í•˜ë©´ ë²¡í„° A + Bë¥¼ ì–»ëŠ” ê²ƒìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
(ë‘ ë²¡í„° aì™€ bë¥¼ ë”í•œ ë²¡í„° a+bëŠ” bì˜ ì‹œì‘ì ì„ aì˜ ëì ìœ¼ë¡œ ì˜®ê²¼ì„ ë•Œ bì˜ ëì ì—ì„œ ëë‚˜ëŠ” ë²¡í„°ì´ë‹¤. ë‘ ë²¡í„°ì˜ ì¢Œí‘œë¥¼ ê°ê° ë”í•´ì„œ ê²°ê³¼ ë²¡í„°ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.)

- ë²¡í„°ì˜ ëº„ì…ˆ: ë²¡í„° Aì—ì„œ ë²¡í„° Bë¥¼ ëº„ ë•Œ, ë²¡í„° Bì˜ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ë²¡í„° Aë¥¼ ì´ë™ì‹œí‚¨ ë²¡í„°ë¥¼ ì–»ìŠµë‹ˆë‹¤. ì´ëŠ” ë²¡í„° Bì˜ ë°˜ëŒ€ ë°©í–¥ ë²¡í„°ë¥¼ ë²¡í„° Aì— ë”í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤.(í•œ ë²¡í„° aì—ì„œ ë‹¤ë¥¸ ë²¡í„° bë¥¼ ëº€ ë²¡í„° a-bëŠ” bì˜ ëì ì—ì„œ aì˜ ëì ìœ¼ë¡œ ê°€ëŠ” ë²¡í„°ì´ë‹¤. ë‘ ë²¡í„°ì˜ ì¢Œí‘œë¥¼ ê°ê° ë¹¼ì„œ ê²°ê³¼ ë²¡í„°ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤. ë˜í•œ ì´ë ‡ê²Œ ì •ì˜í•  ê²½ìš° (a-b)+b=aì„ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.)

- ì‹¤ìˆ˜ì™€ì˜ ê³±ì…ˆ: ë²¡í„° Aì— ì‹¤ìˆ˜ë¥¼ ê³±í•˜ë©´ ê·¸ ë²¡í„°ì˜ ê¸¸ì´ê°€ ì‹¤ìˆ˜ë§Œí¼ ë³€í•˜ê³ , ì‹¤ìˆ˜ê°€ ìŒìˆ˜ì¼ ê²½ìš° ë²¡í„°ì˜ ë°©í–¥ì´ ë°˜ëŒ€ê°€ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë²¡í„° Aì— 2ë¥¼ ê³±í•˜ë©´ ê·¸ ê¸¸ì´ëŠ” ì›ë˜ì˜ ë‘ ë°°ê°€ ë˜ê³ , ë²¡í„° Aì— -1ì„ ê³±í•˜ë©´ ê·¸ ë²¡í„°ì˜ ë°©í–¥ì´ ë°˜ëŒ€ê°€ ë©ë‹ˆë‹¤.(í•œ ë²¡í„° aë¥¼ ì‹¤ìˆ˜ rë¡œ ê³±í•œ ë²¡í„° a*rì€ aì˜ ê¸¸ì´ë¥¼ rë°°ë¡œ ëŠ˜ë¦° ë²¡í„°ì´ë‹¤. ë²¡í„°ì˜ ê° ì¢Œí‘œì— rì„ ê³±í•´ì„œ ê²°ê³¼ ë²¡í„°ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.)

ë²¡í„°ì˜ ëŒ€ì†Œ ë¹„êµì—ì„œ ëì ì˜ x ì¢Œí‘œê°€ ì‘ì€ ë²¡í„°ì¼ìˆ˜ë¡, ê·¸ë¦¬ê³  ëì ì˜ x ì¢Œí‘œê°€ ê°™ì„ ê²½ìš° y ì¢Œí‘œê°€ ì‘ì€ ë²¡í„° ì¼ìˆ˜ë¡ ë” ì‘ì€ ë²¡í„°ë¼ê³  ê³„ì‚°í•œë‹¤. ì´ì™€ ê°™ì€ êµ¬ í˜„ì—ëŠ” íŠ¹ë³„í•œ ìˆ˜í•™ì  ì˜ë¯¸ëŠ” ì—†ì§€ë§Œ, ì¢…ì¢… ìœ ìš©í•˜ê²Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

### ì ê³¼ ì§ì„ , ì„ ë¶„ì˜ í‘œí˜„

``` Swift
// ì´ì™€ ê°™ì´ vector êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•´ì„œ ì‰½ê³  í¸í•˜ê²Œ aê°€ bë³´ë‹¤ ì–¼ë§ˆë‚˜ ë” ê°€ê¹Œìš´ì§€ í™•ì¸ê°€ëŠ¥í•˜ë‹¤. 
func howMuchClose(_ p: vector2, _ a: vector2, _ b: vector2) -> Double {
    return (b - p).norm() - (a - p).norm()
}
```

### ë²¡í„°ì˜ ë‚´ì ê³¼ ì™¸ì 

ë²¡í„°ì˜ ë‚´ì (inner product).

ë‘ 2ì°¨ì› ë²¡í„° a=(ax, ay)ì™€ b = (bx, by)ì˜ ë‚´ì  abëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ê³„ì‚°í• ìˆ˜ ìˆëŠ” ì‹¤ìˆ˜ ê°’.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F9anCK%2FbtsgwMlzGRG%2F67Ik23kj3axM3jJLvXlUm0%2Fimg.png)


``` Swift
// ì›ì ì—ì„œ ë²¡í„° bê°€ ë²¡í„° aì˜ ë°˜ì‹œê³„ ë°©í–¥ì´ë©´ ì–‘ìˆ˜, ì‹œê³„ ë°©í–¥ì´ë©´ ìŒìˆ˜,
// í‰í–‰ì´ë©´ 0ì„ ë°˜í™˜í•œë‹¤.
func ccw(a: Vector2, b: Vector2) -> Double {
    return a.cross(rhs: b)
}

// ì  Pë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë²¡í„° bê°€ ë²¡í„° aì˜ ë°˜ì‹œê³„ ë°©í–¥ì´ë©´ ì–‘ìˆ˜, ì‹œê³„ ë°©í–¥ì´ë©´ ìŒìˆ˜,
// í‰í–‰ì´ë©´ 0ì„ ë°˜í™˜í•œë‹¤.
func ccw(p: Vector2, a: Vector2, b: Vector2) -> Double {
    return ccw(a: a - p, b: b - p)
}
```

## êµì°¨ì™€ ê±°ë¦¬, ë©´ì 

### ì§ì„ ê³¼ ì§ì„ ì˜ êµì°¨

``` Swift
// (a, b)ë¥¼ í¬í•¨í•˜ëŠ” ì„ ê³¼ (c, d)ë¥¼ í¬í•¨í•˜ëŠ” ì„ ì˜ êµì ì„ xì— ë°˜í™˜í•œë‹¤.
// ë‘ ì„ ì´ í‰í–‰ì´ë©´ (ê²¹ì¹˜ëŠ” ê²½ìš°ë¥¼ í¬í•¨) falseë¥¼, ì•„ë‹ˆë©´ trueë¥¼ ë°˜í™˜í•œë‹¤.
func lineIntersection(a: Vector2, b: Vector2, c: Vector2, d: Vector2) -> (Bool, Vector2?) {
    let det = (b - a).cross(rhs: d - c)
    // ë‘ ì„ ì´ í‰í–‰ì¸ ê²½ìš°
    if abs(det) < .epsilon { return (false, nil) }
    let x = a + (b - a) * ((c - a).cross(rhs: d - c) / det)
    return (true, x)
}
```

### ì„ ë¶„ê³¼ ì„ ë¶„ì˜ êµì°¨

1. ë‘ì„ ë¶„ì´ì„œë¡œ ê²¹ì¹˜ì§€ ì•ŠìŒ
2. ë‘ ì„ ë¶„ì´ í•œ ì ì—ì„œ ë‹¿ìŒ
3. ë‘ ì„ ë¶„ì´ ê²¹ì³ì§
4. í•œ ì„ ë¶„ì´ ë‹¤ë¥¸ ì„ ë¶„ ì•ˆì— í¬í•¨ë¨

``` Swift
// (a, b)ì™€ (c, d)ê°€ í‰í–‰í•œ ë‘ ì„ ë¶„ì¼ ë•Œ ì´ë“¤ì´ í•œ ì ì—ì„œ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸í•œë‹¤
func parallelSegments(a: Vector2, b: Vector2, c: Vector2, d: Vector2) -> (Vector2?, Bool) {
    var a = a, b = b, c = c, d = d
    if b < a { swap(&a, &b) }
    if d < c { swap(&c, &d) }
    // í•œ ì§ì„  ìœ„ì— ì—†ê±°ë‚˜ë‘ ì„ ë¶„ì´ ê²¹ì¹˜ì§€ ì•ŠëŠ” ê²½ìš°ë¥¼ìš°ì„  ê±¸ëŸ¬ë‚¸ë‹¤.
    if ccw(a: a, b: b, c: c) != 0 || b < c || d < a { return (nil, false) }
    // ë‘ ì„ ë¶„ì€ í™•ì‹¤íˆ ê²¹ì¹œë‹¤. êµì°¨ì ì„ í•˜ë‚˜ ì°¾ì.
    let p: Vector2 = a < c ? c : a
    return (p, true)
}

// pê°€ (a, b)ë¥¼ ê°ì‹¸ë©´ì„œ ê° ë³€ì´ x, yì¶•ì— í‰í–‰í•œ ìµœì†Œ ì‚¬ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
// a, b, pëŠ” ì¼ì§ì„  ìƒì— ìˆë‹¤ê³  ê°€ì •í•œë‹¤.
func inBoundingRectangle(p: Vector2, a: Vector2, b: Vector2) -> Bool {
    var a = a, b = b
    if b < a { swap(&a, &b) }
    return p == a || p == b || (a < p && p < b)
}

// (a, b) ì„ ë¶„ê³¼ (c, d) ì„ ë¶„ì˜ êµì ì„ pì— ë°˜í™˜í•œë‹¤.
// êµì ì´ ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ì•„ë¬´ ì ì´ë‚˜ ë°˜í™˜í•œë‹¤.
// ë‘ ì„ ë¶„ì´ êµì°¨í•˜ì§€ ì•Šì„ ê²½ìš° false# ë°˜í™˜í•œë‹¤.
func segmentIntersection(a: Vector2, b: Vector2, c: Vector2, d: Vector2) -> (Vector2?, Bool) {
    var p: Vector2? = nil
    // ë‘ ì§ì„ ì´ í‰í–‰ì¸ ê²½ìš°ë¥¼ ìš°ì„  ì˜ˆì™¸ë¡œ ì²˜ë¦¬í•œë‹¤.
    if let intersection = lineIntersection(a: a, b: b, c: c, d: d).0 {
        p = intersection
    } else {
        return parallelSegments(a: a, b: b, c: c, d: d)
    }
    // pê°€ ë‘ ì„ ë¶„ì— í¬í•¨ë˜ì–´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì°¸ì„ ë°˜í™˜í•œë‹¤.
    if let p = p {
        return (p, inBoundingRectangle(p: p, a: a, b: b) && inBoundingRectangle(p: p, a: c, b: d))
    }
    return (nil, false)
}

```

### ì„ ë¶„ê³¼ ì„ ë¶„ì˜ êµì°¨: êµì°¨ì ì´ í•„ìš” ì—†ì„ ë•Œ

``` Swift
// ë‘ ì„ ë¶„ì´ ì„œë¡œ ì ‘ì´‰í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ë°˜í™˜í•œë‹¤.
func segmentIntersects(a: Vector2, b: Vector2, c: Vector2, d: Vector2) -> Bool {
    var a = a, b = b, c = c, d = d
    let ab = ccw(a: a, b: b, c: c) * ccw(a: a, b: b, c: d)
    let cd = ccw(a: c, b: d, c: a) * ccw(a: c, b: d, c: b)
    // ë‘ ì„ ë¶„ì´ í•œ ì§ì„  ìœ„ì— ìˆê±°ë‚˜ ëì ì´ ê²¹ì¹˜ëŠ” ê²½ìš°
    if ab == 0 && cd == 0 {
        if b < a { swap(&a, &b) }
        if d < c { swap(&c, &d) }
        return !(b < c || d < a)
    }
    return ab <= 0 && cd <= 0
}
```

### ì ê³¼ ì„  ì‚¬ì´ì˜ ê±°ë¦¬

``` Swift
// ì  Pì—ì„œ (a, b) ì§ì„ ì— ë‚´ë¦° ìˆ˜ì„ ì˜ ë°œì„ êµ¬í•œë‹¤.
func perpendicularFoot(p: Vector2, a: Vector2, b: Vector2) -> Vector2 {
    return a + (p - a).project(rhs: b - a)
}

// ì  Pì™€ (a, b) ì§ì„  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ êµ¬í•œë‹¤.
func pointToLine(p: Vector2, a: Vector2, b: Vector2) -> Double {
    return (p - perpendicularFoot(p: p, a: a, b: b)).norm
}
```

---

## PINBALL 

[PINBALL sudo ğŸ”—](ComputationalGeometry/PINBALL.swift)

---

## POLYGON

[POLYGON sudo ğŸ”—](ComputationalGeometry/POLYGON.swift)

---

## TREASURE

[TREASURE sudo ğŸ”—](ComputationalGeometry/TREASURE.swift)

---

## NERDS

[NERDS sudo ğŸ”—](ComputationalGeometry/NERDS.swift)

---

## ê³„ì‚° ê¸°í•˜ ì•Œê³ ë¦¬ì¦˜ ë””ìì¸ íŒ¨í„´

- í‰ë©´ ìŠ¤ìœ„í•‘
- ì§ì‚¬ê°í˜• í•©ì§‘í•©ì˜ ë©´ì 
- ë‹¤ê°í˜• êµì§‘í•©ì˜ ë„“ì´ êµ¬í•˜ê¸°
- êµì°¨í•˜ëŠ” ì„ ë¶„ë“¤
- íšŒì „í•˜ëŠ” ìº˜ë¦¬í¼ìŠ¤

---

## ìì£¼í•˜ëŠ” ì‹¤ìˆ˜ì™€ ìœ ì˜ì ë“¤

- í‡´í™”ë„í˜•
- ì§êµ ì¢Œí‘œê³„ì™€ ìŠ¤í¬ë¦° ì¢Œí‘œê³„
- ë‹¤ë¥¸ ì‹¤ìˆ˜ë“¤
