# 비트마스크(Bitmask)

현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현한다. 

정수의 이진 표현을 자료 구조로 쓰는 기법을 비트마스크라고 한다. 비트마스크는 엄밀하게 말해 자료구조라고는 할 수 없지만, 굉장히 유용하게 사용된다. 

### 장점
- **더 빠른 수행 시간**: 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 적절히 사용할 경우 다른 자료 구조를 사용하는 것보다 훨씬 빠르게 동작한다.
- **더 간결한 코드**: 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있기 때문에 비트마스크를 적절히 사용하면 굉장히 짧은 코드를 작성할 수 있다. 
- **더 작은 메모리 사용량**: 비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있다. 더 적은 메모리를 사용한다는 말은 더 많은 데이터를 미리 계산해서 저장해 둘 수 있다는 뜻. 더 많은 데이터를 미리 계산해 둘수 있으면 프로그램도 빨라지고, 더 적은 메모리를 사용하는 프로그램은 일반적으로 캐시 효율도 더 좋다.
- **연관 배열을 배열로 대체**: c++에서 불린 값 배열을 키로 갖는 연관 배열 객체 map <vector<bool>, int>를 사용하고 있다고 할때. 이때 비트마스크를 써서 같 은 정보를 정수 변수로 나타내면 단순한 배열 int[]를 사용해 같은 정보를 나 타낼 수 있다. 많은 경우 이 기법은 엄청난 시간과 메모리의 차이를 불러 온다.

## 용어 정의

이진수의 한 자리를 bit라고 부른다. 비트는 0 혹은 1의 값을 가질 수 있다. 컴퓨터가 표현하는 모든 자료의 근간이 된다. 부호 없는 8비트 정수형은 여덟 자리 이진수로 표시할 수 있는 모든 정수를 표현할 수 있다. 따라서 부호 없는 8비트 정수형이 가지 수 있는 최소값은 0, 최대값은 1111 1111₂ = 255

부호 없는 N비트 정수형 변수는 N자리 이진수로 쓸 수 있다. 2⁰ ~ 2ᴺ⁻¹. 이때 최상위 비트(most significant bit)는 2ᴺ⁻¹이고, 2⁰는 최하위 비트(least significant bit)가 된다. 이진수로 표현했을 때 어떤 비트의 위치가 1이면 해당 비트가 "켜져 있다"라고 하고, 0이라면 "꺼져 있다" 라고 한다.

### 비트 연산자

|연산|코드|
|---|---|
|두 정수 a, b를 비트별로 AND 연산| a & b |
|두 정수 a, b를 비트별로 OR 연산| a \| b |
|두 정수 a, b를 비트별로 XOR 연산 | a ^ b |
|정수 a의 비트별 NOT 연산 결과 | 〜a |
|정수 a를 왼쪽으로 b비트 시프트 | a << b |
|정수 시를 오른쪽으로 b비트 시프트 | a >> b |

### 유의할 점들

- 연산자 간 우선순위를 혼동하는 것. (혼동하지 않으려면 괄호를 자세하게 추가하는 습관을 들여야 한다.)
- 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로 

---

## 비트마스크를 이용한 집합의 구현

비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것. 이 표현에서 N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 된다. 이때 원소 i가 집합에 속해 있는지 여부는 2ⁱ을 나타내는 비트가 켜져 있는지 여부로 나타낸다. 예를 들어 여섯 개의 원소를 갖는 집합 [1, 4, 5, 6, 7, 9]을 표현하는 정수는 754임을 다음과 같이 알수 있다.

2^1+2^4+2^5+2^6+2^7+2^9 = 10 1111 0010₂=754

### 피자집ㅈ 예제
