# [**동적 계획법 전통 최적화 문제들**](https://chanhhh.tistory.com/173)

## 9 문제: Quantization (문제 ID： QUANTIZE, 난이도: 중)

Quantization(양자화) 과정은, 더 넓은 범위를 갖는 값들을 작은 범위를 갖는
값들로 근사해 표현함으로써 자료를 손실 압축하는 과정을 말합니다. 예를 들
어 16비트 JPG 파일을 4컬러 GIF 파일로 변환하는 것은 RGB 색 공간의 색들
을 4컬러 중의 하나로 양자화하는 것이며, 키가 161,164,178,184인 학생 넷을
‘160대 둘, 170대 하나, 180대 하나이라고 축약해 표현하는 것 또한 양자화라고
할수있습니다.
1,000 이하의 자연수들로 구성된 수열을 5가지의 자연수만을 사용하도록 양
자화하려고 합니다. 양자화를 하는 방법은 여러 가지가 있습니다. 수열 1 2 3 4
5 6 7 8 9 10을 두 가지의 숫자만을 써서 표현하려면, 3 3 3 3 3 7 7 7 7 7과 같이
표현할 수도 있고, 1 1 1 1 1 10 10 10 10 10으로 할 수도 있지요. 우리는 이 중
각 숫자별 오차 제곱의 합을 최소화하는 양자화 결과를 알고 싶습니 다.
예를 들어 수열 1 2 3 4 5를 2 2 3 3 3으로 양자화하면 각 숫자별 오차는 -1, 0,
0, 1, 2이고, 오차 제곱의 합은 1+0 + 0+1+4 = 6이 됩니다. 그러나 2 2 2 4 4로
양자화하면 오차 제곱의 합은 1+0 +1+0 +1=3이 됩니다. 수열과 5가 주어질
때, 가능한 한 오차 제곱의 합의 최소치를 구하는 프로그램을 작성하세요.

### 시간 및 메모리 제한

프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 합 니다.

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C(l<C<50)7} 주어집니다. 각 테스트
케이스의 첫 줄에는 수열의 길이 n(l玄n玄100), 사용할 숫자의 수 引1玄5玄10)
가 주어집니다. 그 다음 줄에 n개의 정수로 수열의 숫자들이 주어지며, 수열의
모든 수는 1,000 이하의 자연수입니다.

### 출력

각 테스트 케이스마다 한 줄에 주어진 수열을 5개의 수로 양자화할 때 오차 제
곱의 합의 최소치를출력합니다.

### 예제 입력

```
2
10 3
3331232221
9 3
1 744 755 4 897 902 890 6 777
```

### 예제 출력

```
e
651
```

---

## 풀이: Quantization

### 하던 대로는안 된다

지금까지의 연습 문제와는 달리 이 문제는 주어진 그대로 재귀적인 해법을 찾
으려고 하면 성공할 수 없습니다. 단순하게 생각해 보면 양자화된 결과 수열을
답으로 생각하고, 맨 앞의 숫자에서부터 하나씩 채워 나가는 접근 방법을 택하
게 됩니다. 주어진 수열 A의 첫 번째 숫자를 어떤 숫자로 표현할 것인지를 결정
하고, 나머지 수열에 대해 재귀 호출로 문제를 해결하는 식이지요. 이런 형태의
재귀 호출 함수를 사용하면 될까요?
砂a%ze（A）=A에 속한수를 양자화해서 얻을수 있는 최소오차제곱의 합
그런데 이 문제에서는 사용할 수 있는 숫자의 가짓수에 제한이 있기 때문에
남은 문제를 재귀적으로 해결할 때는 이 함수처럼 지금까지 사용한 숫자들을
무시할 수가 없습니 다. 이 미 5가지의 숫자를 다 쓴 상태라면 이 중 하나의 숫자
를 선택해야 하기 때문입니다. 다시 말하면 최적 부분 조건이 성립하지 않는다
는이야기지요.
이렇듯 quantize（、）는 남은 숫자들만이 아니라 이전 숫자들을 어떤 숫자로 양
자화했는지 또한 알아야 하기 때문에, 지금까지 사용한 숫자들의 집합 또한 입
력으로 받아야 합니다. 결국 다음과 같은 형태의 함수를 구현하게 됩니다.
quantized, U>UA 지금까지 한 번 이상 사용한 숫자들의 집합일 때 A에
속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합
그러면 烈=?가（>는 A의 첫 번째 숫자를 어떻게 표현할지를 결정하고 나머지
를 재귀 호출해서 해결하게 됩니다. 그러나 이런 완전 탐색 코드는 실로 엄청나
게 많은 수의 답을 하나하나 만들게 됩니다. 원본 수열에 포함된 수들의 범위가
1,000 이하의 자연수이니, 引의 크기가 10인 경우에만도 （저쯔0）개의 부분문제가
존재할 수 있지요. 메모이제이션에 필요한 메모리를 확보할 수 없는 것은 물론
이고, 아마 인류문명이 멸망할 때까지 답을 구할수 없을 겁니다.

### 답의 형태 제한하기

이와 같이 부분 문제의 개수가 너무 많을 때 우리가 시도할 수 있는 방법은 굉
장히 많습니다. 그중 이 문제에 유용하게 쓰이는 방법은 답이 항상 어떤 구조를
가질 것이라고 예측하고 그것을 강제하는 것입니다.
답이 갖는 구조를 예측한다고 해서 꼭 복잡한 것은 아닙 니다. 예제 입 력을 포
함한 작은 입력 몇 개를 손으로 풀어 보면, 두 숫자 «<b에 대해 a에 대응되는
숫자가 그에 대응되는 숫자보다 커서는 안 된다는 사실을 깨달을 수 있습니다.
예를 들어 1을 7로 바꿨는데, M 6으로 바꾸는 것은 절대로 최적해가 될 수 없
습니다. 대응되는 두 숫자를 서로 바꾸면 항상 더 작은 오차를 얻을 수 있기 때
문이죠. 이것을 좀더 일반화하면 다음과 같이 주장할 수 있습니다.
주어진 수열을 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다!
예를 들어 보면 좀더 당연합니다. {1, 2, 3, 4}를 양자화하는데, 최적해가 {2, 2,
3, 2}와 같은 형태일 리는 없는 거죠. 이렇게 생각하면 이 문제를 해결하는 방법
이 보입니다. 우선 입력에 주어지는 수들을 정렬한 뒤, 인접한 숫자끼리 묶음으
로 적절히 분할하고, 각 묶음을 한 숫자로 표현해서 오류를 최소화하는 것이지
요. 오차 제곱의 합은 각 숫자의 순서가 변하더라도 상관 없기 때문에 이와 같
이 풀 수 있습니다.

따라서 이 문제는 이제 주어진 수열을 5개의 묶음으로 나누는 문제가 됩니다.
이것은 비교적 쉽게 재귀적으로 해결할 수 있지요! 매 재귀 호출 때마다, 첫 묶
음의 크기가 얼마일지를 결정하면 됩니다. 첫 묶음의 크기를x라고 한다면 이제
나머지 n-x개의 숫자를 S-1개의 묶음으로 나누면 되죠. 이때 나머지 5-1 묶음
의 오류 합이 최소여야 전체도 최소 오류이기 때문에, 최적 부분 구조 또한 성
립한다는 것을 알 수 있습니다
번째 이후의 숫자들을 pa%개의 묶음으로 묶을 때, 최소 오류 제곱 합
을 반환하는 함수 quantize (from, parts)가 있다고 합시 다. pa%개 의 묶음 중
첫 번째의 크기는 1 이상 이하의 값이므로, 이들을 각각 다 계산해 보
면 되겠지요. 첫 번째 묶음의 크기가 立w일 때의 최소 오류는 minError(from,
from + size -1) + quantize (from + size, parts -1)°] 됩 니 다. (、minError(、a, 으治 a
번째 숫자부터 b번째 숫자까지를 하나의 수로 표현했을 때의 최소 오류를 반환
한다고 합시다.)
따라서 다음과 같은 점화식이 성립합니다.

```
quantize (from, parts) = min [minError (from,from + size -1) +
size=^
quantize (from+size, parts -1)]
```

이 점화식을 구현하면 동적 계획법 알고리즘을 얻을 수 있지요. 아aMzeO가
이전 묶음들에 대한 정보를 전혀 입력받지 않는다는 것을 눈여겨봅시다. 남은
숫자들을 최적으로 묶는 데 이전 조각의 정보는 필요가 없지요. 이것은 이 문제
에서도 최적 부분 조건이 성립함을 나타냅니다.

### 한 개의 구간에 대한 답 찾기

위에서 언급한 minErrorO를 실제로 어떻게 구현해야 할까요? minError{a, b)
에서 해야하는 일은크게 두가지입니다.
1. 주어진 구간을 어떤 수로 표현해야 할지 결정하기
2. 결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기
이 문제의 시간 제한은 이들을 가능한 한 간단한 방법을 이용해 풀더라도 문
제를 해결할 수 있게끔 조정되어 있지만, 여기에서는 참고 삼아 다른 방법들 또
한 이야기해 보겠습니다.
우선 해당 구간을 표현할 숫자를 결정하는 방법들에 대해 생각해 보죠. 무식
하게 풀 수 있을까?라는 질문에 가장 적절하게 대답한 예는, 바로 가능한 모든
숫자를 다 시도해 본다는 것입니다. 예를 들어 {74, 81, 96, 10아을 한 숫자로 표
현하려 면, 74부터 100까지 하나하나 시도해 보며 오류를 최소화하는 숫자를 고
릅니 다. 모든 구간에 대해 답을 미 리 계산해 두려면 이 방법은 이론상 수행해야
하는 반복문의 수가 n3X1000에 비례하지만, 대부분의 경우 구간 길이는 n보다
짧고, 사용 가능한 종류 수는 1000보다 작기 때문에 시간 안에 나올 수도 있습
니다.
복잡한 계산 과정이 귀찮다면 위와 같은 방법을 사용할 수도 있지만, 미분을
이용하면 길이 2 이상인 구간 수열 A[a•••方]에 대해 오차 제곱의 합을 최소화하
는 ”을 쉽게 찾을 수 있습니다. 오차 제곱의 합을 다음과 같이 풀어 써 봅시다.

이 식은 w에 대한 2차식이고, 2차항의 계수가 양수이므로 미분을 통해 최소
점을 찾을 수 있습니다. m에 대해 미분한 뒤, 0이 되는 점을 다음 식을 풀어서
찾을수 있지요.
마지막 식을 주목해 봅시다. 여기서 계산하는 데 오래 걸리는 부분은 A[]2의
부분합과 A[]의 부분합인데, 이들은 w과는 관련이 없습니다. 따라서 한 번 더
부분 합을 사용해 이 식을 0(1)에 계산하는 것이 가능합니다.
이상의 방법에 의해 minError(a, b＞를 0⑴에 계산할 수 있습니다. 따라서 알
고리즘의 전체 시간 복잡도는 부분 문제의 수 0(=)에 각 부분 문제의 답을 계
산하는 데 드는 시간 0(n)을 곱한 0(/八)가 됩니다.


### 구현

코드 8.15는 지금껏 설명한 동적 계획법 알고리즘의 구현을 보여줍니다. 앞
에서 논의한 바와 같이 두 개의 부분합 배열 pSum[]A p5"w[]을 이용해
minError ()를 0(1)에 계산한 부분을 눈여 겨 보시 기 바랍니 다.

``` Swift


```

---

## 경우의 수와 확률

동적 계획법은 애초에 최적화 문제를 풀기 위해 고안되었다고 말했습니다만,
경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용됩니다. 경우의 수
를 계산하는 문제는 많은 경우 재귀적인 특징을 가지고 있기 때문이죠. 8.1 절에
서 처음 예로 들었던 이항 계수를 구하는 문제도 경우의 수를 계산하는 문제니
까요.

### 오버플로에 유의하기
실제 예제에 들어가기 전에 모든 경우의 수를 세는 문제에서 유의해야 할 점에
대해 잠시 얘기하겠습니다. 대개 경우의 수를 세는 문제에서 답은 입력의 크기
에 대해 지수적으로 증가하기 마련입니다. 애초에 그렇지 않다면 동적 계획법
을 쓸 것도 없이 완전 탐색을 이용해 모든 답을 만들면서 세어볼 수 있었을 테
니까요. 그래서 많은 경우 답이 일반적으로 우리가 사용하는 32비트 정수형의
한계를 초과하기 십상입니다. 물론 큰 정수 구현을 요구할 수도 있지만, 큰 정
수를 구현하기가 매우 번거롭다 보니 배보다 배꼽이 커지는 결과를 불러오기
쉽습니다. 그래서 대부분의 문제에서는 답을 어떤 수 M으로 나눈 나머지를 출
력하기를 요구하는 식으로 이런 현상을 해결합니다. 이를 위해서 14.8절에서
다루는 모듈라 연산에 관련된 식을 미 리 알아 두는 것이 좋습니다.


## 예제: 타일링 방법의 수 세기 （문제 ID： TILING2

2x« 크기의 사각형을 2X1 크끼의 타일로 채우는 방법의 수를 계산하는 문제
를 예로 들어 봅시다. 타일들은 서로 겹쳐서는 안 되고, 90도로 회전해서 쓸 수
있습니다. 예를 들어 n = 5라고 하면 그림 8.7과 같이 여덟 가지의 방법이 있지
요. «의 최대 값이 100이라고 할 때 타일을 채우는 방법의 수를 어떻게 셀 수 있
을까요?

우선 완전 탐색을 이용해 모든 답을 만들면서 개수를 세어 보는 함수를 작성
한 뒤, 메모이제이션을 이용해 동적 계획법 알고리즘으로 바꿔 봅시다. 재귀 호
출을 이용해 모든 타일링 방법을 만들려면 각 타일링 방법을 여러 조각으로 쪼
개고 함수가 재귀 호출될 때마다 한 조각씩 만들어 나가면 됩니 다. 여 기서는 매
조각마다 2〉아 사각형의 맨 왼쪽 세로줄을 덮어 나가기로 합시다

2〉＜« 사각형을 채우는 모든 방법들은 맨 왼쪽 세로줄이 어떻게 채워져 있느
냐로 나눌 수 있습니다. 이 세로줄은 왼쪽 그림처럼 한 개의 세로 타일에 의해
덮여 있을 수도 있고, 오른쪽 그림처럼 두 개의 가로 타일에 의해 덮여 있을 수
도 있지요. 이때 다음의 조건들이 성립함을 알수 있습니다.
• 이 두 가지 분류는 타일링하는 방법을 모두 포함합니다.
• 두 가지 분류에 모두 포함되는 타일링 방법은 없습니다.
이 두 가지 속성은 경우의 수를 셀 때 항상 확인해야 하는 조건입니다. 부분
문제 분할이 첫 번째 조건을 위반한다면 알고리즘은 실제 수보다 적은 답을 내
놓게 됩니다. 모든 한국인의 수를 세려고 하는데, 모든 한국인은 부산 사람이거
나 대전 사람이라고 생각하는 것과 마찬가지죠. 반대로 두 번째 조건을 위반하
는 부분 문제 분할이 이루어지면, 실제보다 많은 수의 답을 세게 됩니다. 모든
한국인의 수를 세려고 하는데, 모든 한국인이 열 살 이상 혹은 미성 년자라고 생
각하는 것과 같습니다. 이 방법에서는 열 살이 넘는 미성년자들은 두 번 세어지
게 되겠죠.
다행히도 타일링 문제에서는 이 두 가지의 성질이 성립한다는 것을 쉽게 알
수 있으며, 따라서 각 단계에서 이 세로줄을 세로 타일 하나로 덮을 것인지 가
로 타일 두 개로 덮을 것인지를 결정하기만 하면 됩니다. 남은 공간은 각각 2X
(n-1), 2x(n-2) 크기의 사각형이 되므로, 재귀 호출을 이용해 각 경우의 수를
쉽게 계산할수 있지요.
따라서 다음과 같은 형태의 부분 문제를 정의할 수 있습니다.
tiling(n) = 2 x W 크기의 사각형을 타일로 덮는 방법을 반환한다.
rz7zVig()에 역시 이전 부분들을 어떻게 덮었는지에 관한 정보는 들어가 있
지 않다는 데 유의하세요. 입력 n이 일정할 경우, 이전 부분을 어떻게 덮었든지
tiling()의 반환 값도 일정하니까요. tiling()이 한 번 호출될 때 할 수 있는 선택
이 세로 타일 하나를 쓰느냐, 가로 타일 두 개를 쓰느냐임을 생각하면, 다음과
같은 점화식이 성립함을 알 수 있습니다.
tiling (n) = tiling (n -1) + tiling (n - 2)
입력은 항상 [0, n] 구간의 정수이므로, 이 함수는 메모이제이션을 써서 쉽게
최적화할 수 있지요. 코드 8.16이 이러한 메모이제이션을 보여줍니다. 경우의
수를 반환하는 것이 아니라 로 나눈 나머지를 반환한다는 데 유의하세요.
乃이 100이면 경우의 수는 64비트 정수형의 표현 범위도 훌쩍 넘어가는 큰 값
이 되기 때문이죠. rz7z‘ng()이 반환하는 최대치는 W>1인데, 이 값을 더해도
2지 -1 이 넘어가지 않으므로 중간 값 오버플로가 발생하지 않는다는 점도 눈여
겨 보세요.

### 구현

``` Swift

```

## 예제: 삼각형 위의 최대 경로 개수 세기 

8.4절에서 다뤘던 삼각형 위의 최대 경로 찾기 문제를 돌이켜 봅시다. 우리는
최대 경로의 합을 구했을 뿐이지, 경로 자체는 구하지 않았습니다. 왜냐면 많은
삼각형에서 최대 경로는 유일하지 않기 때문입니다. 예를 들어 그림 8.8(a)의
삼각형에는 세 개의 최대 경로가 있습니다. (9, 7, 2, 6}과 {9, 7, 3, 5}의 합이 모
두 24이고, {9, 7, 3, 5}는 두 번 등장하거든요. "이 커질 경우에 최대 경로의 수
를 어떻게 계산할 수 있을까요?
이 문제를 해결하기 위해서는 두 개의 다른 동적 계획법 문제를 해결해야 합
니다. 먼저 바탕이 되는 최적화 문제를 푼 뒤, 각 부분 문제마다 최적해의 개
수를 계산하는 동적 계획법 알고리즘을 만드는 것이죠. 물론 최적해를 구하는
문제는 8.4절에서 이미 풀었기 때문에, 그림 8.8(a) 삼각형의 각 위치에 대해
path2{^ 결과를 써서 그림 8.8(b)를 얻을 수 있습니다.


이 그림이 있으면 (0, 0)에서 시작하는 최대 경로는 (1, 0)과 (1, 1) 중 어느 쪽
으로 내려가야할지를 쉽게 알수 있습니다.pW2(l, 1)>@W(1, 0)이기 때문
에 항상 (1, 1)으로 내려가는 것이 이득이기 때문이지요. 따라서 (0, 0)에서 시
작하는 최대 경로의 개수는 항상 (1, 1)에서 시작하는 최대 경로의 개수와 같습
니다.
그러면 (1, 1)에서 시작하는 최대 경로는 어느 쪽으로 내려가야 할까요? 이 경
우에는 내려갈 수 있는 두 칸에서 만들 수 있는 최대 경로의 합이 같기 때문에,
어느 쪽으로 내려가도 최대 경로를 만들 수 있죠. 이때 (1, 1)에서 시작하는 모
든 최대 경로는 이 두 분류 중 정확히 하나에 포함된다는 것을 주목합시다. 따
라서 두 위치에서 시작하는 최단 경로의 개수를 더한 것이 (1, 1)에서 시작하는
최대 경로의 개수가 됩니다.
이것을 좀더 일반화해서 다음과 같은 함수 country, x)를 만들기로 합시다.
count(y, x) = (y, 시에서 시작해 맨 아래줄까지 내려가는 최대 경로의 수
이 경로에서 (y, x)의 다음 칸은path2(y+l, x)과path2(y+l, x + 1) 중 어느
쪽이 더 큰지에 따라 결정됩니다. 앞에서 본 바를 점화식으로 옮기면 다음과 같
을겁니다.
• count(y + l,x) (/7aZA2(y + l,x)>parA2(y + l,jc+：0)
country, x)-max - count(y+l,x + i) q7tzfA2(y+1, x)<pa比2(y +1, x+1》
. 1,x) + camZ(y+1, x+1)
q?af/z2(y+1, x)=path2(y+l, x+1))
코드 8.17이 이 함수의 메모이제이션 구현을 보여줍니다. 이 코드는 8.9에서
작성했던 path2 ()를 가져 다 씁니다.


``` Swift
8.17


```

## 예제: 우물을 기어오르는 달팽이

획률과 경우의 수에는 밀접한 관련이 있기 때문에 많은 경우 확률을 계산하는
문제에도 동적 계획법을 써먹을 수 있습니다. 다음과 같은 예제 문제를 살펴봅
시다. 깊이가 H미터인 우물의 맨 밑바닥에 달팽이가 있습니다. 이 달팽이는 우
물의 맨 위까지 기어올라가고 싶어하는데, 달팽이의 움직임은 그 날의 날씨에
좌우됩니다. 만약 날이 맑으면 달팽이는 하루에 2미터를 기어올라갈 수 있지
만, 비가 내리면 1미터밖에 올라가지 못합니다. 앞으로 w일 간 각 날짜에 비가
올 확률이 정확히 50%라고 가정할 때, ⑦일 안에 달팽이가 우물 끝까지 올라갈
확률은 얼마나 될까요?

경우의 수로 확률 계산하기
각 날마다 비가 오거나 오지 않거나 둘 중 하나이니, 가능한 끼일 간 날씨의 조
합은 모두 2m가지입니다. 각 날마다 달팽이가 몇 미터나 기어오를 수 있는지로
날씨를 표현한다면, 다음과 같은 형태가 되겠지요.
{1, 1,1, I,-, 1,1, 1}
{1,1,1,1,-, 1,1, 2}
{1,1,1, 그,…, 1,2,1}
{2, 2, 2, 2,-, 2, 2, 1}
{2, 2, 2, 2,-, 2, 2, 2}
이때 각 조합이 출현할 확률은 모두 같습니다. 따라서 위 날씨 조합 중 합이 n이상인 조합의 수를 센 뒤, 전체 조합의 수인 2”으로 나누면 간단하게 이 확률
을 계산할 수 있지요.


### 완전 탐색 알고리즘

모든 날씨 조합을 하나하나 만들어 보는 완전 탐색 알고리즘으로부터 시작합시
다. 각 조합을 m 조각으로 잘라 재귀 호출의 각 단계에서 하루 날씨가 맑을지, 맑
지 않을지를 결정하려고 합니다. 다음과 같은 부분 문제를 정의할 수 있겠지요.
cZz’"(C') = 지금까지 만든 날씨 조합 C'를 완성해서 원소의 합이 n 이상이 되
도록 하는 방법의 수
climbO는 오늘 날씨가 맑은 경우와 비가 오는 경우를 모두 세기 때문에, 다
음과 같은 점화식으로 정의할수 있습니다.
climb (C') = climb (C' + [l]) + c/i7nb (C'+ [2])
(C'+ lx]는 배열 C'의 맨 뒤에 x를 덧붙인 결과라고 합시다.) 다만 이런 부분
문제 정의로는 C'의 종류가 너무 많기 때문에 메모이제이션을 적용할 수가 없
습니다. 과거에 우리가 한 선택에 대한 정보는 최소한도로 줄이는 것이 좋지요.
C'에서 우리가 쓰는 정보는 지금까지 C'의 길이와 C의 원소들의 합 뿐이니 다
음과 같이 부분 문제 정의를 바꿀 수 있습니다.
climb (days, cZZ/nbeJ) = 지 금까지 만든 날씨 조합 C'의 크기가 成씌이고 그
원소들의 합이 climbed일 때, C'를완성해서 원소의 합이 n 이상이 되게 하는
방법의 수
다르게 말하면, 달팽이가 days일 동안 미터를 기어올라 왔을 때 m일
전까지 n미터 이상 기어오를 수 있는 경우의 수를 계산한다고도 할 수 있지요.
이 부분 문제는 최대 nxw개의 부분 문제만을 갖기 때문에 수월하게 메모이
제이션을 적용할 수 있지요. 코드 8.18이 이의 구현을 보여줍니다. 결과적으로
얻은 경우의 수를 2”으로 나누면 최종 확률을 얻을 수 있지요.

### 구현

``` Swift
코드 8.18


```

## 예제: 장마가 찾아왔다 (문제 ID： SNAIL,

여름 장마가 찾아와 매일 비가 올 확률이 50%에서 75%로 올라갔다고 합시다.
그러면 날씨의 조합마다 출현할확률이 달라질 수 있지요. 이럴 때는 경우의 수
를 계산하지 않고 직접 확률을 계산합니다. 물론 문제가 바뀐 것은 아니기 때문
에 부분 문제의 구조는 그대로 유지할 수가 있습니다. 다음과 같이 바꿔 보기로
하지요.
climb2(days, cZ/z?止>兄) = 달팽이가 지금까지 ctays일 동안 cZZwb"?미터를 기
어올라 왔을 때 ⑦일 전까지 «미터 이상 기 어올라갈 수 있을 확률
오늘 비가 올 경우와 오지 않을 경우, 달팽이가 우물을 탈출할 확률은 각각
climb2 (days +1, climbed+1)과 climb2 (days +1, climbed + 2)로 표현할 수 있
습니다. 다른 점은 각각의 사건이 일어날 확률이 다르다는 점이죠. 각각의 확률
을 곱하면 다음과 같은 점화식을 얻을 수 있습니다.
climb2 (days, climbed) = 0.75 x climb2 (days +1, climbed+1)
+ 0.25 x climb2 (days +1, climbed+ 2)
이 함수는 경우의 수 대신에 확률을 직접 반환한다는 차이밖에 없기 때문에
메모이제이션을 이용해 쉽게 최적화할 수 있습니다.

경우의 수 계산하기 레시피
1. 모든 답을 직접 만들어서 세어보는 완전 탐색 알고리즘을 설계합니다. 이때
경우의 수를 제대로 세기 위해서는 재귀 호출의 각 단계에서 고르는 각 선택
지에 다음과 같은 속성이 성립해야 합니다.
a） 모든 경우는 이 선택지들에 포함됨
b） 어떤 경우도 두 개 이상의 선택지에 포함되지 않음
2. 최적화 문제를 해결할 때처럼 이전 조각에서 결정한 요소들에 대한 입력을
없애거나 변형해서 줄입니다. 재귀 함수는 앞으로 남아 있는 조각들을 고르
는 경우의 수만을 반환해야합니다.
3. 메모이제이션을 적용합니다.

---